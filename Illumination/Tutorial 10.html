<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/glsl.min.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script>
            hljs.configure({"languages": ["c++", "glsl"]})
            $(document).ready(function() {
              $('pre').each(function(i, block) {
                hljs.highlightBlock(block);
              });
            });
        </script><title>Chapter 10. Plane Lights</title><link rel="stylesheet" type="text/css" href="../chunked.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="../index.html" title="Learning Modern 3D Graphics Programming"><link rel="up" href="Illumination.html" title="Part III. Illumination"><link rel="prev" href="Tut09%20Glossary.html" title="Glossary"><link rel="next" href="Tut10%20Interpolation.html" title="Interpolation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 10. Plane Lights</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="Tut09%20Glossary.html">Prev</a> </td><th width="60%" align="center">Part III. Illumination</th><td width="20%" align="right"> <a accesskey="n" href="Tut10%20Interpolation.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="idp70"></a>Chapter 10. Plane Lights</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="Tutorial%2010.html#idp8266">Vertex Point Lighting</a></span></dt><dt><span class="section"><a href="Tut10%20Interpolation.html">Interpolation</a></span></dt><dt><span class="section"><a href="Tut10%20Fragment%20Lighting.html">Fragment Lighting</a></span></dt><dt><span class="section"><a href="Tut10%20Distant%20Points%20of%20Light.html">Distant Points of Light</a></span></dt><dt><span class="section"><a href="Tut10%20In%20Review.html">In Review</a></span></dt><dt><span class="section"><a href="Tut10%20Glossary.html">Glossary</a></span></dt></dl></div>
    
    
    <p>Directional lights are useful for representing light sources like the sun and so forth.
        But most light sources are more likely to be represented as point lights.</p>
    <p>A <em class="glossterm">point light source</em> is a light source that has a position in the
        world and shines with equal intensity in all directions. Our simple diffuse lighting
        equation is a function of these properties:</p>
    <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <p>The surface normal at that point.</p>
        </li><li class="listitem">
            <p>The direction from the point on the surface to the light.</p>
        </li></ul></div>
    <p>The direction to the light source from the point is a constant when dealing with
        directional light. It is a parameter for lighting, but it is a constant value for all points
        in the scene. The difference between directional lighting and point lights is only that this
        direction must be computed for each position in the scene.</p>
    <p>Computing this is quite simple. At the point of interest, we take the difference between
        the point on the surface and the light's position. We normalize the result to produce a unit
        vector direction to the light. Then we use the light direction as we did before. The surface
        point, light position, and surface normal must all be in the same space for this equation to
        make sense.</p>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp8266"></a>Vertex Point Lighting</h2></div></div></div>
        
        
        <p>Thus far, we have computed the lighting equation at each vertex and interpolated the
            results across the surface of the triangle. We will continue to do so for point lights.
            For the moment, at least.</p>
        <p>We implement point lights per-vertex in the <span class="propername">Vertex Point
                Lighting</span> tutorial. This tutorial has a moving point light that circles
            around the cylinder.</p>
        <div class="figure"><a name="idp8271"></a><p class="title"><b>Figure 10.1. Vertex Point Lighting</b></p><div class="figure-contents">
            
            <div class="mediaobject"><img src="Vertex%20Point%20Lighting.png" alt="Vertex Point Lighting"></div>
        </div></div><br class="figure-break">
        <p>To toggle an indicator of the light's position, press the <span class="keycap"><strong>Y</strong></span> key. The
                <span class="keycap"><strong>B</strong></span> key will toggle rotation of the light. The <span class="keycap"><strong>I</strong></span> and
                <span class="keycap"><strong>K</strong></span> keys move the light up and down respectively, while the
                <span class="keycap"><strong>J</strong></span> and <span class="keycap"><strong>L</strong></span> keys will decrease and increase the
            light's radius. Holding shift with these keys will move in smaller increments.</p>
        <p>Most of the code is nothing we have not seen elsewhere. The main changes are at the top
            of the rendering function.</p>
        <div class="example"><a name="idp8284"></a><p class="title"><b>Example 10.1. Per-Vertex Point Light Rendering</b></p><div class="example-contents">
            
            <pre class="programlisting">glutil::MatrixStack modelMatrix;
modelMatrix.SetMatrix(g_viewPole.CalcMatrix());

const glm::vec4 &amp;worldLightPos = CalcLightPosition();

glm::vec4 lightPosCameraSpace = modelMatrix.Top() * worldLightPos;

glUseProgram(g_WhiteDiffuseColor.theProgram);
glUniform3fv(g_WhiteDiffuseColor.lightPosUnif, 1, glm::value_ptr(lightPosCameraSpace));
glUseProgram(g_VertexDiffuseColor.theProgram);
glUniform3fv(g_VertexDiffuseColor.lightPosUnif, 1, glm::value_ptr(lightPosCameraSpace));</pre>
        </div></div><br class="example-break">
        <p>The light is computed initially in world space, then transformed into camera space.
            The camera-space light position is given to both of the shaders. Rendering proceeds
            normally from there.</p>
        <p>Our vertex shader, <code class="filename">PosVertexLighting_PCN.vert</code> has had a few
            changes:</p>
        <div class="example"><a name="idp8290"></a><p class="title"><b>Example 10.2. Per-Vertex Point Light Vertex Shader</b></p><div class="example-contents">
            
            <pre class="programlisting">#version 330

layout(location = 0) in vec3 position;
layout(location = 1) in vec4 diffuseColor;
layout(location = 2) in vec3 normal;

smooth out vec4 interpColor;

uniform vec3 lightPos;
uniform vec4 lightIntensity;
uniform vec4 ambientIntensity;

uniform mat4 modelToCameraMatrix;
uniform mat3 normalModelToCameraMatrix;

uniform Projection
{
    mat4 cameraToClipMatrix;
};

void main()
{
    vec4 cameraPosition = (modelToCameraMatrix * vec4(position, 1.0));
    gl_Position = cameraToClipMatrix * cameraPosition;
    
    vec3 normCamSpace = normalize(normalModelToCameraMatrix * normal);
    
    vec3 dirToLight = normalize(lightPos - vec3(cameraPosition));
    
    float cosAngIncidence = dot(normCamSpace, dirToLight);
    cosAngIncidence = clamp(cosAngIncidence, 0, 1);
    
    interpColor = (diffuseColor * lightIntensity * cosAngIncidence) +
        (diffuseColor * ambientIntensity);
}</pre>
        </div></div><br class="example-break">
        <p>The vertex shader takes a camera-space light position instead of a camera-space light
            direction. It also stores the camera-space vertex position in a temporary in the first
            line of <code class="function">main</code>. This is used to compute the direction to the light.
            From there, the computation proceeds normally.</p>
        <p>Note the order of operations in computing <code class="varname">dirToLight.</code> The
                <code class="varname">lightPos</code> is on the left and the <code class="varname">cameraPosition</code>
            is on the right. Geometrically, this is correct. If you have two points, and you want to
            find the direction from point A to point B, you compute B - A. The
                <code class="function">normalize</code> call is just to convert it into a unit vector.</p>
    </div>
    
    
    
    
    
    
</div><a class="github-fork-ribbon left-top" href="https://github.com/paroj/gltut" title="Fork me on GitHub">Fork me on GitHub</a><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Tut09%20Glossary.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="Illumination.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="Tut10%20Interpolation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Glossary </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Interpolation</td></tr></table></div></body></html>
